#!/bin/bash

PATH=$PATH:/bin:/usr/bin:/usr/local/bin
l_progName=$0
l_top_srcdir=""
l_flags=""
l_outputName=""
l_objects=""

function usage
{
  echo "usage : ${l_progName} --top-srcdir=DIR flags archivename [objects]"
  echo ""
	echo "Creates archive 'archivename' from 'objects' with bazaar version informations"
	echo ""
  echo "[parameters]"
  echo "  --top-srcdir=DIR  : top input source directory"
	echo "  --help            : display this message"
  exit 1;
}


function readOptions
{
  while true; do
    case "$1" in
      --top-srcdir)
        l_top_srcdir=$2;
        shift 2;;
      --help)
				usage;;
      --)
        shift;
        break;;
      *)
        echo "error: internal problem while parsing options"
        usage;;
    esac
  done

  l_flags=$1
  shift
  l_outputName=$1
  shift
  l_objects="$*"
}


function checkOptions
{
  if [ ! -d "${l_top_srcdir}" ]; then
    echo "invalid input --top-srcdir='${l_top_srcdir}'"
    usage
  fi
}


function generateArchive
{
  l_libName=$(echo ${l_outputName} | sed 's/\.a//g')
  l_tmpDir=$(mktemp -d)
  l_tmpFile=${l_tmpDir}/${l_outputName}.version

  l_header=$(printf "$%s: (time)" "${l_libName}")
  l_date=$(date +"%H:%M:%S")
  printf "%-20s %s $  " "${l_header}" "${l_date}" >> ${l_tmpFile}
  l_header=$(printf "$%s: (date)" "${l_libName}")
  l_date=$(date +"%b %d %Y")
  printf "%-20s %s $  " "${l_header}" "${l_date}" >> ${l_tmpFile}

  if [ -d "${l_top_srcdir}/.git" ]; then
    l_revno=$(cd "${l_top_srcdir}" && git rev-parse HEAD)
  elif [ -d "${l_top_srcdir}/.bzr" ]; then
    l_revno=$(cat "${l_top_srcdir}/.bzr/branch/last-revision")
  else
    l_revno="xxxx"
  fi

  l_header=$(printf "$%s: (revno)" "${l_libName}")
  printf "%-20s %s $  " "${l_header}" "${l_revno}" >> ${l_tmpFile}

  ar ${l_flags} ${l_outputName} ${l_objects} ${l_tmpFile}
  rm -rf ${l_tmpDir}
}

l_parseResult=`/usr/bin/getopt -o h\
		--long top-srcdir:,help \
	-n "${l_progName}" -- "$@"`

if [ $? != 0 ]; then
  usage
fi

eval set -- "${l_parseResult}"

readOptions "$@"
checkOptions
generateArchive "$@"
